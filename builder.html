<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Maria's Word Vault ‚Äî Puzzle Builder</title>
<link href="https://fonts.googleapis.com/css2?family=Playfair+Display:wght@400;600;700;800&family=DM+Mono:wght@400;500&family=DM+Sans:wght@400;500;600;700&display=swap" rel="stylesheet">
<style>
:root {
  --ink: #1a1208;
  --ink-soft: #3d3224;
  --ink-faint: #6b5d4f;
  --paper: #faf7f2;
  --paper-warm: #f5f0e8;
  --paper-dim: #ebe5d9;
  --gold: #c9943a;
  --gold-light: #e8c97a;
  --gold-dim: #8a6420;
  --rust: #b84c2a;
  --sage: #4a7c5e;
  --sage-light: #d4e8dc;
}

*, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

html { height: 100%; }

body {
  font-family: 'DM Sans', sans-serif;
  background: var(--paper);
  color: var(--ink);
  min-height: 100%;
  padding: 24px;
}

body::before {
  content: '';
  position: fixed; inset: 0;
  background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='n'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.9' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23n)' opacity='0.03'/%3E%3C/svg%3E");
  pointer-events: none;
  z-index: 9999;
}

.builder-container {
  max-width: 640px;
  margin: 0 auto;
}

.builder-header {
  text-align: center;
  margin-bottom: 32px;
}

.builder-rule {
  width: 60px; height: 2px;
  background: var(--gold);
  margin: 0 auto 12px;
}

.builder-title {
  font-family: 'Playfair Display', serif;
  font-size: clamp(1.5rem, 5vw, 2rem);
  font-weight: 800;
  color: var(--ink);
}

.builder-subtitle {
  font-family: 'DM Mono', monospace;
  font-size: 0.7rem;
  color: var(--ink-faint);
  letter-spacing: 3px;
  text-transform: uppercase;
  margin-top: 6px;
}

.builder-back {
  font-family: 'DM Mono', monospace;
  font-size: 0.75rem;
  color: var(--ink-faint);
  text-decoration: none;
  display: inline-block;
  margin-top: 10px;
}
.builder-back:hover { color: var(--gold); }

/* Form sections */
.section {
  margin-bottom: 24px;
}

.section-title {
  font-family: 'DM Mono', monospace;
  font-size: 0.7rem;
  letter-spacing: 2px;
  text-transform: uppercase;
  color: var(--ink-faint);
  border-bottom: 1px solid var(--paper-dim);
  padding-bottom: 6px;
  margin-bottom: 12px;
}

.form-input {
  font-family: 'DM Sans', sans-serif;
  font-size: 0.95rem; font-weight: 500;
  padding: 10px 14px;
  border: 2px solid var(--paper-dim);
  border-radius: 2px;
  background: white;
  color: var(--ink);
  outline: none;
  width: 100%;
  transition: border-color 0.2s;
}
.form-input:focus { border-color: var(--gold); }

.form-label {
  font-family: 'DM Mono', monospace;
  font-size: 0.65rem;
  color: var(--ink-faint);
  letter-spacing: 1px;
  text-transform: uppercase;
  margin-bottom: 4px;
  display: block;
}

/* Word list */
.word-entry {
  display: flex;
  gap: 8px;
  margin-bottom: 8px;
  align-items: flex-start;
}

.word-entry input:first-child {
  width: 140px;
  flex-shrink: 0;
  text-transform: uppercase;
  font-family: 'DM Mono', monospace;
  letter-spacing: 1px;
}

.word-entry input:last-of-type {
  flex: 1;
}

.word-entry button {
  background: none;
  border: 2px solid var(--paper-dim);
  border-radius: 2px;
  color: var(--rust);
  cursor: pointer;
  font-size: 0.85rem;
  padding: 8px 10px;
  flex-shrink: 0;
}

.btn {
  font-family: 'Playfair Display', serif;
  font-size: 0.9rem;
  font-weight: 700;
  padding: 10px 20px;
  border: none;
  border-radius: 2px;
  cursor: pointer;
  transition: all 0.12s;
}

.btn-gold {
  background: var(--gold);
  color: white;
  box-shadow: 0 2px 0 var(--gold-dim);
}
.btn-gold:active { transform: translateY(2px); box-shadow: none; }

.btn-sage {
  background: var(--sage);
  color: white;
  box-shadow: 0 2px 0 #375e46;
}

.btn-outline {
  background: transparent;
  color: var(--ink-faint);
  border: 2px solid var(--paper-dim);
}

.btn-small {
  font-family: 'DM Mono', monospace;
  font-size: 0.7rem;
  font-weight: 500;
  padding: 6px 12px;
}

.button-row {
  display: flex;
  gap: 8px;
  flex-wrap: wrap;
  margin-top: 12px;
}

/* Quick-add presets */
.preset-chips {
  display: flex;
  flex-wrap: wrap;
  gap: 6px;
  margin-top: 8px;
}

.preset-chip {
  font-family: 'DM Mono', monospace;
  font-size: 0.65rem;
  padding: 4px 10px;
  border: 1px solid var(--paper-dim);
  border-radius: 2px;
  background: white;
  color: var(--ink-faint);
  cursor: pointer;
  transition: all 0.15s;
}
.preset-chip:hover {
  border-color: var(--gold);
  color: var(--ink);
}

/* Preview grid */
.preview-area {
  margin-top: 16px;
  text-align: center;
}

.preview-grid {
  display: inline-grid;
  gap: 0;
  border: 2px solid var(--ink);
}

.preview-cell {
  width: 32px; height: 32px;
  border: 0.5px solid #ccc;
  display: flex;
  align-items: center;
  justify-content: center;
  font-family: 'DM Sans', sans-serif;
  font-size: 0.65rem;
  font-weight: 700;
  color: var(--ink);
  position: relative;
}

.preview-cell.black {
  background: var(--ink);
}

.preview-cell .pnum {
  position: absolute;
  top: 1px; left: 2px;
  font-size: 0.45rem;
  font-weight: 700;
  color: var(--ink-faint);
}

/* Status messages */
.status {
  font-family: 'DM Mono', monospace;
  font-size: 0.75rem;
  margin-top: 8px;
  padding: 8px 12px;
  border-radius: 2px;
}
.status-success { background: var(--sage-light); color: var(--sage); }
.status-error { background: #fde8e4; color: var(--rust); }
.status-info { background: #e8f0fa; color: #4a6d8c; }
</style>
</head>
<body>
<div class="builder-container">
  <div class="builder-header">
    <div class="builder-rule"></div>
    <div class="builder-title" style="font-family:'Playfair Display',serif">Puzzle Builder</div>
    <div class="builder-subtitle">Maria's Word Vault</div>
    <a href="index.html" class="builder-back">‚Üê Back to Game</a>
  </div>

  <!-- Puzzle Name -->
  <div class="section">
    <div class="section-title">Puzzle Title</div>
    <input type="text" id="puzzleTitle" class="form-input" placeholder="e.g., Family Favorites" maxlength="60">
  </div>

  <!-- Word List -->
  <div class="section">
    <div class="section-title">Words & Clues</div>
    <div id="wordList"></div>
    <div class="button-row">
      <button class="btn btn-outline btn-small" onclick="addWordRow()">+ Add Word</button>
    </div>

    <div class="section-title" style="margin-top:16px">Quick Add ‚Äî Family Presets</div>
    <div class="preset-chips">
      <button class="preset-chip" onclick="addPreset('BAOBAO','Our beloved first pup')">üêï Bao Bao</button>
      <button class="preset-chip" onclick="addPreset('ROXI','Our pittie princess')">üêï‚Äçü¶∫ Roxi</button>
      <button class="preset-chip" onclick="addPreset('BATMAN','The Dark Knight')">ü¶á Batman</button>
      <button class="preset-chip" onclick="addPreset('BRUCE','Mr. Wayne himself')">üé≠ Bruce</button>
      <button class="preset-chip" onclick="addPreset('JEEP','Wrangler ride')">üöô Jeep</button>
      <button class="preset-chip" onclick="addPreset('WRANGLER','Terencio\'s ride')">üèîÔ∏è Wrangler</button>
      <button class="preset-chip" onclick="addPreset('SXSW','Austin festival')">üé∏ SXSW</button>
      <button class="preset-chip" onclick="addPreset('AUSTIN','Texas capital, our city')">ü§† Austin</button>
      <button class="preset-chip" onclick="addPreset('AMAZON','Former employer, the everything store')">üì¶ Amazon</button>
      <button class="preset-chip" onclick="addPreset('LYFT','Former gig, rideshare company')">üöó Lyft</button>
      <button class="preset-chip" onclick="addPreset('MARIA','Mom, the queen')">üëë Maria</button>
      <button class="preset-chip" onclick="addPreset('DC','District of Columbia, home base')">üèõÔ∏è DC</button>
      <button class="preset-chip" onclick="addPreset('ERRANT','Knight without a kingdom')">‚öîÔ∏è Errant</button>
      <button class="preset-chip" onclick="addPreset('CONGRESS','Famous bat bridge in ATX')">üåâ Congress</button>
    </div>
  </div>

  <!-- Grid Size -->
  <div class="section">
    <div class="section-title">Grid Size</div>
    <div style="display:flex;gap:8px;align-items:center">
      <input type="number" id="gridSize" class="form-input" value="9" min="5" max="15" style="width:80px">
      <span style="font-family:'DM Mono',monospace;font-size:0.7rem;color:var(--ink-faint)">√ó grid (5-15)</span>
    </div>
  </div>

  <!-- Actions -->
  <div class="section">
    <div class="button-row">
      <button class="btn btn-gold" onclick="generatePreview()">üî® Build Crossword</button>
      <button class="btn btn-sage" onclick="savePuzzle()" id="btnSave" style="display:none">üíæ Save to Vault</button>
      <button class="btn btn-outline btn-small" onclick="exportJSON()" id="btnExport" style="display:none">üìã Export JSON</button>
    </div>
    <div id="statusMsg"></div>
  </div>

  <!-- Preview -->
  <div class="section">
    <div class="section-title">Preview</div>
    <div class="preview-area" id="previewArea">
      <div style="font-family:'DM Mono',monospace;font-size:0.75rem;color:var(--ink-faint)">Add words and click "Build Crossword" to see your puzzle</div>
    </div>
    <div id="previewClues"></div>
  </div>
</div>

<!-- Firebase SDK -->
<script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-database-compat.js"></script>

<script>
const firebaseConfig = {
  apiKey: "AIzaSyDkqQsKeNwL4qL5e-J1P5S3UE1puzcOaC0",
  authDomain: "marias-word-vault.firebaseapp.com",
  databaseURL: "https://marias-word-vault-default-rtdb.firebaseio.com",
  projectId: "marias-word-vault",
  storageBucket: "marias-word-vault.firebasestorage.app",
  messagingSenderId: "605567866404",
  appId: "1:605567866404:web:9dc0e6543e20e11105eab1"
};

firebase.initializeApp(firebaseConfig);
const db = firebase.database();

let builtPuzzle = null;

// Initialize with 3 empty word rows
function init() {
  for (let i = 0; i < 3; i++) addWordRow();
}

function addWordRow(word = '', clue = '') {
  const list = document.getElementById('wordList');
  const row = document.createElement('div');
  row.className = 'word-entry';
  row.innerHTML = `
    <input type="text" class="form-input" placeholder="WORD" value="${word}" maxlength="15" style="text-transform:uppercase;font-family:'DM Mono',monospace;letter-spacing:1px;width:140px">
    <input type="text" class="form-input" placeholder="Clue for this word..." value="${clue}">
    <button onclick="this.parentElement.remove()">‚úï</button>
  `;
  list.appendChild(row);
}

function addPreset(word, clue) {
  addWordRow(word, clue);
}

function getWordList() {
  const rows = document.querySelectorAll('.word-entry');
  const words = [];
  rows.forEach(row => {
    const inputs = row.querySelectorAll('input');
    const word = inputs[0].value.trim().toUpperCase().replace(/[^A-Z]/g, '');
    const clue = inputs[1].value.trim();
    if (word.length >= 2 && clue) {
      words.push({ word, clue });
    }
  });
  return words;
}

/* ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê CROSSWORD LAYOUT ENGINE ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê */

function buildCrosswordLayout(wordList, maxSize) {
  if (wordList.length === 0) return null;

  // Sort by length descending
  const sorted = [...wordList].sort((a, b) => b.word.length - a.word.length);
  const grid = Array.from({ length: maxSize }, () => Array(maxSize).fill(null));
  const placed = [];

  // Place first word horizontally in the middle
  const first = sorted[0];
  const startRow = Math.floor(maxSize / 2);
  const startCol = Math.floor((maxSize - first.word.length) / 2);

  if (startCol < 0 || startCol + first.word.length > maxSize) {
    return null;
  }

  for (let i = 0; i < first.word.length; i++) {
    grid[startRow][startCol + i] = first.word[i];
  }

  placed.push({
    word: first.word,
    clue: first.clue,
    row: startRow,
    col: startCol,
    dir: 'across'
  });

  // Try to place remaining words
  for (let wi = 1; wi < sorted.length; wi++) {
    const entry = sorted[wi];
    let bestPlacement = null;
    let bestScore = -1;

    // For each placed word, find intersections
    for (const p of placed) {
      for (let pi = 0; pi < p.word.length; pi++) {
        for (let ei = 0; ei < entry.word.length; ei++) {
          if (p.word[pi] !== entry.word[ei]) continue;

          // Calculate position
          const newDir = p.dir === 'across' ? 'down' : 'across';
          let newRow, newCol;

          if (newDir === 'down') {
            newRow = p.row - ei;
            newCol = p.dir === 'across' ? p.col + pi : p.col;
          } else {
            newRow = p.dir === 'down' ? p.row + pi : p.row;
            newCol = p.col - ei;
          }

          // Check bounds
          if (newRow < 0 || newCol < 0) continue;
          if (newDir === 'across' && newCol + entry.word.length > maxSize) continue;
          if (newDir === 'down' && newRow + entry.word.length > maxSize) continue;

          // Check if placement is valid
          if (canPlace(grid, entry.word, newRow, newCol, newDir, maxSize)) {
            const score = scoreIntersections(grid, entry.word, newRow, newCol, newDir);
            if (score > bestScore) {
              bestScore = score;
              bestPlacement = { word: entry.word, clue: entry.clue, row: newRow, col: newCol, dir: newDir };
            }
          }
        }
      }
    }

    if (bestPlacement) {
      // Place it
      for (let i = 0; i < bestPlacement.word.length; i++) {
        const r = bestPlacement.dir === 'across' ? bestPlacement.row : bestPlacement.row + i;
        const c = bestPlacement.dir === 'across' ? bestPlacement.col + i : bestPlacement.col;
        grid[r][c] = bestPlacement.word[i];
      }
      placed.push(bestPlacement);
    }
  }

  if (placed.length < 2) return null;

  // Assign clue numbers
  const numberMap = {};
  let num = 1;
  for (let r = 0; r < maxSize; r++) {
    for (let c = 0; c < maxSize; c++) {
      if (grid[r][c] === null) continue;
      const needsNumber = placed.some(p => p.row === r && p.col === c);
      if (needsNumber && !numberMap[`${r}_${c}`]) {
        numberMap[`${r}_${c}`] = num++;
      }
    }
  }

  // Build final data
  const gridData = grid.map(row => row.map(cell => cell || '#'));
  const across = [];
  const down = [];
  const answers = {};

  for (const p of placed) {
    const key = `${p.row}_${p.col}`;
    const clueNum = numberMap[key] || 1;
    const clueObj = {
      number: clueNum,
      clue: p.clue,
      answer: p.word,
      row: p.row,
      col: p.col,
      dir: p.dir
    };
    if (p.dir === 'across') {
      across.push(clueObj);
    } else {
      down.push(clueObj);
    }
    answers[`${p.dir}_${clueNum}`] = p.word;
  }

  across.sort((a, b) => a.number - b.number);
  down.sort((a, b) => a.number - b.number);

  return {
    source: 'custom',
    title: document.getElementById('puzzleTitle').value.trim() || 'Family Puzzle',
    gridData,
    clues: { across, down },
    answers,
    placed: placed.length,
    total: sorted.length
  };
}

function canPlace(grid, word, row, col, dir, maxSize) {
  // Check cell before word start (must be empty or out of bounds)
  if (dir === 'across') {
    if (col > 0 && grid[row][col - 1] !== null) return false;
    if (col + word.length < maxSize && grid[row][col + word.length] !== null) return false;
  } else {
    if (row > 0 && grid[row - 1][col] !== null) return false;
    if (row + word.length < maxSize && grid[row + word.length][col] !== null) return false;
  }

  for (let i = 0; i < word.length; i++) {
    const r = dir === 'across' ? row : row + i;
    const c = dir === 'across' ? col + i : col;

    if (r >= maxSize || c >= maxSize) return false;

    const existing = grid[r][c];

    if (existing !== null) {
      // Must match
      if (existing !== word[i]) return false;
    } else {
      // Check adjacency ‚Äî no parallel touching
      if (dir === 'across') {
        if (r > 0 && grid[r - 1][c] !== null) return false;
        if (r < maxSize - 1 && grid[r + 1][c] !== null) return false;
      } else {
        if (c > 0 && grid[r][c - 1] !== null) return false;
        if (c < maxSize - 1 && grid[r][c + 1] !== null) return false;
      }
    }
  }

  return true;
}

function scoreIntersections(grid, word, row, col, dir) {
  let score = 0;
  for (let i = 0; i < word.length; i++) {
    const r = dir === 'across' ? row : row + i;
    const c = dir === 'across' ? col + i : col;
    if (grid[r][c] === word[i]) score += 2;
  }
  return score;
}

/* ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê PREVIEW ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê */

function generatePreview() {
  const words = getWordList();
  if (words.length < 2) {
    showStatus('Need at least 2 words with clues', 'error');
    return;
  }

  const size = parseInt(document.getElementById('gridSize').value) || 9;
  const puzzle = buildCrosswordLayout(words, size);

  if (!puzzle) {
    showStatus('Could not build a crossword ‚Äî try different words or a larger grid', 'error');
    return;
  }

  builtPuzzle = puzzle;

  // Render preview grid
  const area = document.getElementById('previewArea');
  area.innerHTML = '';

  const gridDiv = document.createElement('div');
  gridDiv.className = 'preview-grid';
  gridDiv.style.gridTemplateColumns = `repeat(${size}, 32px)`;

  for (let r = 0; r < size; r++) {
    for (let c = 0; c < size; c++) {
      const cell = document.createElement('div');
      cell.className = 'preview-cell';
      if (puzzle.gridData[r][c] === '#') {
        cell.classList.add('black');
      } else {
        cell.textContent = puzzle.gridData[r][c];
        // Check for number
        const hasNum = [...puzzle.clues.across, ...puzzle.clues.down].find(cl => cl.row === r && cl.col === c);
        if (hasNum) {
          const numSpan = document.createElement('span');
          numSpan.className = 'pnum';
          numSpan.textContent = hasNum.number;
          cell.appendChild(numSpan);
        }
      }
      gridDiv.appendChild(cell);
    }
  }
  area.appendChild(gridDiv);

  // Render clues
  const clueDiv = document.getElementById('previewClues');
  clueDiv.innerHTML = '';

  const makeList = (title, clues) => {
    if (clues.length === 0) return '';
    let html = `<div class="section-title" style="margin-top:12px">${title}</div>`;
    for (const cl of clues) {
      html += `<div style="font-size:0.8rem;padding:3px 0;color:var(--ink-soft)"><strong style="font-family:'DM Mono',monospace;font-size:0.7rem;color:var(--gold-dim)">${cl.number}.</strong> ${cl.clue} <span style="color:var(--ink-faint);font-size:0.7rem">(${cl.answer.length})</span></div>`;
    }
    return html;
  };

  clueDiv.innerHTML = makeList('Across', puzzle.clues.across) + makeList('Down', puzzle.clues.down);

  // Show status
  showStatus(`‚úì Placed ${puzzle.placed} of ${puzzle.total} words`, 'success');

  // Show save/export buttons
  document.getElementById('btnSave').style.display = '';
  document.getElementById('btnExport').style.display = '';
}

/* ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê SAVE / EXPORT ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê */

async function savePuzzle() {
  if (!builtPuzzle) {
    showStatus('Build the crossword first!', 'error');
    return;
  }

  try {
    const ref = db.ref('custom_puzzles').push();
    await ref.set({
      ...builtPuzzle,
      created: firebase.database.ServerValue.TIMESTAMP
    });
    showStatus('‚úì Saved to vault! Go play it.', 'success');
  } catch (e) {
    showStatus('Error saving: ' + e.message, 'error');
  }
}

function exportJSON() {
  if (!builtPuzzle) return;
  const json = JSON.stringify(builtPuzzle, null, 2);
  navigator.clipboard?.writeText(json);
  showStatus('‚úì JSON copied to clipboard', 'info');
}

function showStatus(msg, type) {
  const el = document.getElementById('statusMsg');
  el.className = `status status-${type}`;
  el.textContent = msg;
  setTimeout(() => { el.textContent = ''; el.className = ''; }, 5000);
}

// Init
init();
</script>
</body>
</html>
