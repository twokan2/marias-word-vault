<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Puzzle Builder ‚Äî Maria's Word Vault</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link href="https://fonts.googleapis.com/css2?family=Playfair+Display:wght@400;700;900&family=DM+Mono:wght@400;500&family=DM+Sans:wght@300;400;500&display=swap" rel="stylesheet">

<script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-database-compat.js"></script>

<style>
:root {
  --ink: #1a1208;
  --cream: #f5efe3;
  --paper: #faf7f2;
  --gold: #c9943a;
  --gold-light: #e8c97a;
  --gold-dim: #8a6420;
  --rust: #b84c2a;
  --sage: #4a7c5e;
  --cell-size: 36px;
  --font-display: 'Playfair Display', Georgia, serif;
  --font-mono: 'DM Mono', monospace;
  --font-body: 'DM Sans', sans-serif;
}

*, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

body {
  background: var(--paper);
  color: var(--ink);
  font-family: var(--font-body);
  min-height: 100vh;
}

body::before {
  content: '';
  position: fixed;
  inset: 0;
  background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 256 256' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noise'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.9' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noise)' opacity='0.04'/%3E%3C/svg%3E");
  pointer-events: none;
  z-index: 0;
  opacity: 0.6;
}

.builder-layout {
  display: grid;
  grid-template-columns: 340px 1fr;
  grid-template-rows: auto 1fr;
  min-height: 100vh;
  position: relative;
  z-index: 1;
}

/* Header */
.builder-header {
  grid-column: 1 / -1;
  background: var(--ink);
  color: var(--cream);
  padding: 1rem 1.5rem;
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 1rem;
}

.builder-header h1 {
  font-family: var(--font-display);
  font-size: 1.25rem;
  font-weight: 700;
  color: var(--gold-light);
}

.builder-header p {
  font-family: var(--font-mono);
  font-size: 0.65rem;
  letter-spacing: 0.1em;
  opacity: 0.6;
}

.hdr-btns { display: flex; gap: 0.5rem; align-items: center; }

.btn-gold {
  background: var(--gold);
  color: var(--ink);
  border: none;
  border-radius: 2px;
  padding: 0.6rem 1.2rem;
  font-family: var(--font-display);
  font-weight: 700;
  font-size: 0.9rem;
  cursor: pointer;
  transition: all 0.2s;
}
.btn-gold:hover { background: var(--gold-light); }
.btn-gold:disabled { opacity: 0.4; cursor: not-allowed; }

.btn-ghost {
  background: rgba(255,255,255,0.1);
  color: var(--cream);
  border: 1px solid rgba(255,255,255,0.2);
  border-radius: 2px;
  padding: 0.5rem 1rem;
  font-family: var(--font-body);
  font-size: 0.85rem;
  cursor: pointer;
  transition: all 0.2s;
}
.btn-ghost:hover { background: rgba(255,255,255,0.2); }

/* Left Panel */
.left-panel {
  background: white;
  border-right: 1.5px solid rgba(201,148,58,0.2);
  padding: 1.5rem;
  overflow-y: auto;
  display: flex;
  flex-direction: column;
  gap: 1.25rem;
}

.panel-section h3 {
  font-family: var(--font-mono);
  font-size: 0.65rem;
  letter-spacing: 0.12em;
  text-transform: uppercase;
  color: var(--gold-dim);
  margin-bottom: 0.75rem;
  padding-bottom: 0.4rem;
  border-bottom: 1px solid rgba(201,148,58,0.2);
}

label {
  display: block;
  font-family: var(--font-mono);
  font-size: 0.65rem;
  letter-spacing: 0.1em;
  text-transform: uppercase;
  color: var(--gold-dim);
  margin-bottom: 0.3rem;
}

input[type="text"], textarea {
  width: 100%;
  background: var(--paper);
  border: 1.5px solid rgba(201,148,58,0.3);
  border-radius: 2px;
  padding: 0.55rem 0.7rem;
  font-family: var(--font-mono);
  font-size: 0.85rem;
  color: var(--ink);
  outline: none;
  transition: border-color 0.2s;
}
input:focus, textarea:focus { border-color: var(--gold); }

textarea { resize: vertical; min-height: 60px; }

.word-row {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 0.5rem;
  margin-bottom: 0.5rem;
}

.btn-add {
  width: 100%;
  background: var(--ink);
  color: var(--gold-light);
  border: none;
  border-radius: 2px;
  padding: 0.6rem;
  font-family: var(--font-display);
  font-weight: 700;
  font-size: 0.9rem;
  cursor: pointer;
  transition: all 0.2s;
  margin-top: 0.5rem;
}
.btn-add:hover { background: #2d2010; }

.word-list {
  display: flex;
  flex-direction: column;
  gap: 0.4rem;
  max-height: 300px;
  overflow-y: auto;
}

.word-item {
  display: flex;
  gap: 0.5rem;
  align-items: flex-start;
  padding: 0.6rem 0.7rem;
  border: 1px solid rgba(201,148,58,0.2);
  border-radius: 2px;
  background: var(--paper);
  animation: fadeIn 0.2s ease;
}

@keyframes fadeIn { from { opacity: 0; transform: translateY(-4px); } to { opacity: 1; transform: none; } }

.word-item .wi-word {
  font-family: var(--font-mono);
  font-weight: 500;
  font-size: 0.85rem;
  letter-spacing: 0.05em;
  color: var(--gold-dim);
  min-width: 70px;
  text-transform: uppercase;
}

.word-item .wi-clue {
  font-size: 0.82rem;
  flex: 1;
  line-height: 1.3;
  color: #444;
}

.word-item .wi-delete {
  background: none;
  border: none;
  cursor: pointer;
  color: #ccc;
  font-size: 1rem;
  padding: 0;
  transition: color 0.15s;
  flex-shrink: 0;
}
.word-item .wi-delete:hover { color: var(--rust); }

.status-bar {
  padding: 0.6rem 0.8rem;
  border-radius: 2px;
  font-family: var(--font-mono);
  font-size: 0.72rem;
  text-align: center;
}
.status-bar.info { background: rgba(201,148,58,0.1); color: var(--gold-dim); }
.status-bar.success { background: rgba(74,124,94,0.1); color: var(--sage); }
.status-bar.error { background: rgba(184,76,42,0.1); color: var(--rust); }
.status-bar.hidden { display: none; }

/* Preset words */
.preset-tags {
  display: flex;
  flex-wrap: wrap;
  gap: 0.4rem;
}

.preset-tag {
  background: var(--paper);
  border: 1px solid rgba(201,148,58,0.3);
  border-radius: 2px;
  padding: 0.25rem 0.6rem;
  font-family: var(--font-mono);
  font-size: 0.72rem;
  cursor: pointer;
  transition: all 0.15s;
}
.preset-tag:hover { background: var(--ink); color: var(--gold-light); border-color: var(--ink); }

/* Right Panel - Preview */
.right-panel {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: flex-start;
  padding: 2rem;
  overflow: auto;
  background: var(--paper);
}

.preview-label {
  font-family: var(--font-mono);
  font-size: 0.65rem;
  letter-spacing: 0.12em;
  text-transform: uppercase;
  color: var(--gold-dim);
  margin-bottom: 1rem;
  text-align: center;
}

.crossword-preview {
  display: inline-grid;
  border: 2px solid var(--ink);
  box-shadow: 4px 4px 0 var(--ink);
}

.pcell {
  width: var(--cell-size);
  height: var(--cell-size);
  border: 1px solid #ddd;
  position: relative;
  display: flex;
  align-items: center;
  justify-content: center;
}

.pcell.black { background: var(--ink); }
.pcell.white { background: white; }

.pcell-num {
  position: absolute;
  top: 1px; left: 2px;
  font-family: var(--font-mono);
  font-size: 9px;
  line-height: 1;
  color: #666;
}

.pcell-letter {
  font-family: var(--font-display);
  font-size: 18px;
  font-weight: 700;
  color: var(--ink);
}

.preview-clues {
  margin-top: 1.5rem;
  width: 100%;
  max-width: 500px;
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 1.5rem;
}

.pc-section h4 {
  font-family: var(--font-mono);
  font-size: 0.65rem;
  letter-spacing: 0.12em;
  text-transform: uppercase;
  color: var(--gold-dim);
  margin-bottom: 0.6rem;
}

.pc-clue {
  display: flex;
  gap: 0.4rem;
  margin-bottom: 0.4rem;
  font-size: 0.82rem;
  line-height: 1.35;
}

.pc-num {
  font-family: var(--font-mono);
  font-size: 0.7rem;
  color: var(--gold-dim);
  font-weight: 500;
  min-width: 18px;
  padding-top: 1px;
}

.empty-preview {
  text-align: center;
  padding: 3rem;
  opacity: 0.4;
}

.empty-preview .ep-icon { font-size: 3rem; margin-bottom: 0.75rem; }
.empty-preview p { font-size: 0.85rem; line-height: 1.5; }

::-webkit-scrollbar { width: 4px; }
::-webkit-scrollbar-track { background: transparent; }
::-webkit-scrollbar-thumb { background: rgba(201,148,58,0.3); border-radius: 2px; }
</style>
</head>
<body>

<div class="builder-layout">

  <!-- HEADER -->
  <div class="builder-header">
    <div>
      <h1>‚úèÔ∏è Puzzle Builder</h1>
      <p>Maria's Word Vault ‚Äî Create custom family crosswords</p>
    </div>
    <div class="hdr-btns">
      <button class="btn-ghost" onclick="exportPuzzle()">‚¨á Export JSON</button>
      <button class="btn-gold" id="saveBtn" onclick="savePuzzle()">Save to Cloud ‚òÅ</button>
      <a href="index.html" class="btn-ghost" style="text-decoration:none">‚Üê Back to Game</a>
    </div>
  </div>

  <!-- LEFT: INPUTS -->
  <div class="left-panel">

    <!-- Puzzle info -->
    <div class="panel-section">
      <h3>Puzzle Info</h3>
      <div style="margin-bottom:0.75rem">
        <label>Puzzle title</label>
        <input type="text" id="puzzleTitle" placeholder="e.g. Mom's Birthday Special" maxlength="50">
      </div>
      <div>
        <label>Description (optional)</label>
        <input type="text" id="puzzleDesc" placeholder="e.g. All about our family!" maxlength="100">
      </div>
    </div>

    <!-- Add a word -->
    <div class="panel-section">
      <h3>Add a Word + Clue</h3>
      <div class="word-row">
        <div>
          <label>Word</label>
          <input type="text" id="newWord" placeholder="BAOBAO" maxlength="20" style="text-transform:uppercase"
            onkeydown="if(event.key==='Enter') addWord()">
        </div>
        <div>
          <label>Difficulty</label>
          <select id="wordDifficulty" style="width:100%; padding:0.55rem 0.7rem; background:var(--paper); border:1.5px solid rgba(201,148,58,0.3); border-radius:2px; font-family:var(--font-mono); font-size:0.85rem; outline:none; color:var(--ink)">
            <option value="easy">Easy</option>
            <option value="medium" selected>Medium</option>
            <option value="hard">Hard</option>
          </select>
        </div>
      </div>
      <div style="margin-bottom:0.5rem">
        <label>Clue</label>
        <textarea id="newClue" placeholder="e.g. Our fluffy Shih Tzu" rows="2"
          onkeydown="if(event.key==='Enter' && event.metaKey) addWord()"></textarea>
      </div>
      <button class="btn-add" onclick="addWord()">+ Add Word</button>
    </div>

    <!-- Quick add family presets -->
    <div class="panel-section">
      <h3>Quick Add Family Words</h3>
      <div class="preset-tags" id="presetTags"></div>
    </div>

    <!-- Word list -->
    <div class="panel-section">
      <h3>Words in Puzzle (<span id="wordCount">0</span>)</h3>
      <div class="word-list" id="wordList">
        <div style="text-align:center;font-size:0.8rem;opacity:0.4;padding:0.75rem">
          Add words above to build your puzzle
        </div>
      </div>
    </div>

    <div id="statusBar" class="status-bar hidden"></div>

    <!-- Generate grid controls -->
    <div class="panel-section">
      <h3>Grid Settings</h3>
      <div class="word-row">
        <div>
          <label>Max grid size</label>
          <select id="gridSize" style="width:100%; padding:0.55rem 0.7rem; background:var(--paper); border:1.5px solid rgba(201,148,58,0.3); border-radius:2px; font-family:var(--font-mono); font-size:0.85rem; outline:none; color:var(--ink)">
            <option value="10">10 √ó 10</option>
            <option value="13" selected>13 √ó 13</option>
            <option value="15">15 √ó 15</option>
          </select>
        </div>
        <div>
          <label>Symmetry</label>
          <select id="symmetry" style="width:100%; padding:0.55rem 0.7rem; background:var(--paper); border:1.5px solid rgba(201,148,58,0.3); border-radius:2px; font-family:var(--font-mono); font-size:0.85rem; outline:none; color:var(--ink)">
            <option value="none">None</option>
            <option value="rotational" selected>Rotational</option>
          </select>
        </div>
      </div>
      <button class="btn-add" onclick="generateGrid()">üîÑ Generate Preview</button>
    </div>

  </div>

  <!-- RIGHT: PREVIEW -->
  <div class="right-panel" id="rightPanel">
    <div class="empty-preview" id="emptyPreview">
      <div class="ep-icon">üß©</div>
      <p>Add at least 3 words and<br>click <strong>Generate Preview</strong><br>to see your puzzle</p>
    </div>
  </div>

</div>

<script>
// ===== FIREBASE CONFIG =====
// üîß REPLACE with your Firebase config (same as index.html)
const firebaseConfig = {
  apiKey: "AIzaSyDkqQsKeNwL4qL5e-J1P5S3UE1puzcOaC0",
  authDomain: "marias-word-vault.firebaseapp.com",
  databaseURL: "https://marias-word-vault-default-rtdb.firebaseio.com",
  projectId: "marias-word-vault",
  storageBucket: "marias-word-vault.firebasestorage.app",
  messagingSenderId: "605567866404",
  appId: "1:605567866404:web:9dc0e6543e20e11105eab1"
};

firebase.initializeApp(firebaseConfig);
const db = firebase.database();

// ===== STATE =====
let words = []; // [{word, clue, difficulty}]
let currentGrid = null;
let currentClues = null;

// Family presets ‚Äî customize these!
const FAMILY_PRESETS = [
  { word: 'BAOBAO', clue: 'Our lovable Pitbull' },
  { word: 'ROXI', clue: 'Our other Pitbull baby' },
  { word: 'JEEP', clue: 'Dad\'s ride of choice' },
  { word: 'WRANGLER', clue: 'Type of Jeep we drive' },
  { word: 'AUSTIN', clue: 'City of SXSW' },
  { word: 'SXSW', clue: 'Music and tech festival in ATX' },
  { word: 'TEXAS', clue: 'Our home state' },
  { word: 'AMAZON', clue: 'Where dad used to work' },
  { word: 'LYFT', clue: 'Another company on Dad\'s resume' },
  { word: 'BRUCE', clue: 'Batman\'s real name' },
  { word: 'BATMAN', clue: 'The Dark Knight' },
  { word: 'DC', clue: 'Nation\'s capital' },
  { word: 'SPANISH', clue: 'Language we\'re learning' },
  { word: 'CROSSWORD', clue: 'This very puzzle!' },
  { word: 'FAMILY', clue: 'Most important thing' },
];

// Render preset tags
document.getElementById('presetTags').innerHTML = FAMILY_PRESETS.map(p =>
  `<div class="preset-tag" onclick="usePreset('${p.word}', \`${p.clue}\`)">${p.word}</div>`
).join('');

function usePreset(word, clue) {
  document.getElementById('newWord').value = word;
  document.getElementById('newClue').value = clue;
  document.getElementById('newWord').focus();
}

// ===== WORD MANAGEMENT =====
function addWord() {
  const word = document.getElementById('newWord').value.trim().toUpperCase().replace(/\s/g,'');
  const clue = document.getElementById('newClue').value.trim();
  const difficulty = document.getElementById('wordDifficulty').value;

  if (!word) { showStatus('Enter a word', 'error'); return; }
  if (!clue) { showStatus('Enter a clue for the word', 'error'); return; }
  if (word.length < 2) { showStatus('Word must be at least 2 letters', 'error'); return; }
  if (!/^[A-Z]+$/.test(word)) { showStatus('Word can only contain letters A-Z', 'error'); return; }
  if (words.find(w => w.word === word)) { showStatus('That word is already in the list', 'error'); return; }
  if (words.length >= 30) { showStatus('Max 30 words per puzzle', 'error'); return; }

  words.push({ word, clue, difficulty });
  document.getElementById('newWord').value = '';
  document.getElementById('newClue').value = '';
  renderWordList();
  showStatus(`"${word}" added!`, 'success');
}

function removeWord(idx) {
  words.splice(idx, 1);
  renderWordList();
  currentGrid = null;
}

function renderWordList() {
  const list = document.getElementById('wordList');
  document.getElementById('wordCount').textContent = words.length;

  if (words.length === 0) {
    list.innerHTML = '<div style="text-align:center;font-size:0.8rem;opacity:0.4;padding:0.75rem">No words yet</div>';
    return;
  }

  list.innerHTML = words.map((w, i) => `
    <div class="word-item">
      <div class="wi-word">${w.word}</div>
      <div class="wi-clue">${w.clue}</div>
      <button class="wi-delete" onclick="removeWord(${i})" title="Remove">‚úï</button>
    </div>
  `).join('');
}

// ===== CROSSWORD GRID GENERATOR =====
// A proper backtracking crossword layout algorithm

function generateGrid() {
  if (words.length < 2) {
    showStatus('Add at least 2 words to generate a grid', 'error');
    return;
  }

  const maxSize = parseInt(document.getElementById('gridSize').value);
  showStatus('Generating grid...', 'info');

  setTimeout(() => {
    const result = buildCrosswordLayout(words.map(w => w.word), maxSize);
    if (!result) {
      showStatus('Could not fit all words ‚Äî try fewer words or larger grid', 'error');
      return;
    }
    currentGrid = result;
    currentClues = buildClues(result, words);
    renderPreview(result, currentClues);
    showStatus(`Grid generated! ${result.placedWords.length} words placed`, 'success');
  }, 50);
}

function buildCrosswordLayout(wordList, maxSize) {
  // Sort: longest words first
  const sorted = [...wordList].sort((a, b) => b.length - a.length);

  let placements = []; // [{word, row, col, dir}]
  let grid = Array.from({ length: maxSize }, () => Array(maxSize).fill(null));

  // Place first word horizontally in center
  const firstWord = sorted[0];
  const startCol = Math.floor((maxSize - firstWord.length) / 2);
  const startRow = Math.floor(maxSize / 2);

  placeWord(grid, firstWord, startRow, startCol, 'across');
  placements.push({ word: firstWord, row: startRow, col: startCol, dir: 'across' });

  // Try to place remaining words
  for (let wi = 1; wi < sorted.length; wi++) {
    const word = sorted[wi];
    let placed = false;

    // Try to intersect with already placed words
    const shuffledPlacements = [...placements].sort(() => Math.random() - 0.5);
    
    for (const existing of shuffledPlacements) {
      if (placed) break;
      
      // Find common letters between existing word and new word
      for (let ei = 0; ei < existing.word.length && !placed; ei++) {
        for (let wi2 = 0; wi2 < word.length && !placed; wi2++) {
          if (existing.word[ei] !== word[wi2]) continue;

          // Try perpendicular placement
          let row, col, dir;
          if (existing.dir === 'across') {
            // New word goes down, intersecting at (existing.row, existing.col+ei)
            row = existing.row - wi2;
            col = existing.col + ei;
            dir = 'down';
          } else {
            // New word goes across, intersecting at (existing.row+ei, existing.col)
            row = existing.row + ei;
            col = existing.col - wi2;
            dir = 'across';
          }

          if (canPlace(grid, word, row, col, dir, maxSize)) {
            placeWord(grid, word, row, col, dir);
            placements.push({ word, row, col, dir });
            placed = true;
          }
        }
      }
    }

    if (!placed) {
      // Try placing anywhere valid (fallback ‚Äî may not intersect)
      for (let r = 0; r < maxSize && !placed; r++) {
        for (let c = 0; c < maxSize && !placed; c++) {
          for (const dir of ['across', 'down']) {
            if (canPlace(grid, word, r, c, dir, maxSize)) {
              // Only place if adjacent to existing grid content
              if (isAdjacentToContent(grid, word, r, c, dir, maxSize)) {
                placeWord(grid, word, r, c, dir);
                placements.push({ word, row:r, col:c, dir });
                placed = true;
                break;
              }
            }
          }
        }
      }
    }
  }

  // Trim grid to content
  const trimmed = trimGrid(grid, maxSize);
  
  return {
    grid: trimmed.grid,
    rows: trimmed.rows,
    cols: trimmed.cols,
    offsetRow: trimmed.offsetRow,
    offsetCol: trimmed.offsetCol,
    placedWords: placements.map(p => ({
      ...p,
      row: p.row - trimmed.offsetRow,
      col: p.col - trimmed.offsetCol,
    })),
  };
}

function canPlace(grid, word, row, col, dir, maxSize) {
  if (row < 0 || col < 0) return false;
  const endRow = dir === 'down' ? row + word.length - 1 : row;
  const endCol = dir === 'across' ? col + word.length - 1 : col;
  if (endRow >= maxSize || endCol >= maxSize) return false;

  // Check before start
  const br = dir === 'down' ? row - 1 : row;
  const bc = dir === 'across' ? col - 1 : col;
  if (br >= 0 && bc >= 0 && grid[br][bc] !== null) return false;

  // Check after end
  const ar = dir === 'down' ? endRow + 1 : endRow;
  const ac = dir === 'across' ? endCol + 1 : endCol;
  if (ar < maxSize && ac < maxSize && grid[ar][ac] !== null) return false;

  for (let i = 0; i < word.length; i++) {
    const r = dir === 'down' ? row + i : row;
    const c = dir === 'across' ? col + i : col;
    const existing = grid[r][c];
    
    if (existing === null) {
      // Check perpendicular adjacency (no touching parallel words)
      const pr = dir === 'across' ? r - 1 : r;
      const pc = dir === 'down' ? c - 1 : c;
      const pr2 = dir === 'across' ? r + 1 : r;
      const pc2 = dir === 'down' ? c + 1 : c;
      if ((pr >= 0 && grid[pr][pc] !== null) || (pr2 < maxSize && grid[pr2][pc2] !== null)) return false;
    } else if (existing !== word[i]) {
      return false; // Conflict
    }
  }
  return true;
}

function placeWord(grid, word, row, col, dir) {
  for (let i = 0; i < word.length; i++) {
    const r = dir === 'down' ? row + i : row;
    const c = dir === 'across' ? col + i : col;
    grid[r][c] = word[i];
  }
}

function isAdjacentToContent(grid, word, row, col, dir, maxSize) {
  for (let i = 0; i < word.length; i++) {
    const r = dir === 'down' ? row + i : row;
    const c = dir === 'across' ? col + i : col;
    const neighbors = [
      [r-1,c],[r+1,c],[r,c-1],[r,c+1]
    ];
    for (const [nr,nc] of neighbors) {
      if (nr>=0&&nr<maxSize&&nc>=0&&nc<maxSize&&grid[nr][nc]!==null) return true;
    }
  }
  return false;
}

function trimGrid(grid, maxSize) {
  let minR = maxSize, maxR = 0, minC = maxSize, maxC = 0;
  for (let r = 0; r < maxSize; r++) {
    for (let c = 0; c < maxSize; c++) {
      if (grid[r][c] !== null) {
        minR = Math.min(minR, r);
        maxR = Math.max(maxR, r);
        minC = Math.min(minC, c);
        maxC = Math.max(maxC, c);
      }
    }
  }
  // Add 1-cell padding
  minR = Math.max(0, minR - 1);
  minC = Math.max(0, minC - 1);
  maxR = Math.min(maxSize-1, maxR + 1);
  maxC = Math.min(maxSize-1, maxC + 1);

  const rows = maxR - minR + 1;
  const cols = maxC - minC + 1;
  const trimmedGrid = [];

  for (let r = minR; r <= maxR; r++) {
    const row = [];
    for (let c = minC; c <= maxC; c++) {
      row.push(grid[r][c] === null ? '#' : grid[r][c]);
    }
    trimmedGrid.push(row);
  }

  return { grid: trimmedGrid, rows, cols, offsetRow: minR, offsetCol: minC };
}

function buildClues(layout, wordDefs) {
  const { placedWords } = layout;

  // Assign numbers: scan top-to-bottom, left-to-right, number cells that start an across or down word
  const numberedCells = {};
  const cellNums = {};
  let num = 1;

  // Find all word starts
  const wordStarts = placedWords.map(p => `${p.row},${p.col}`);
  const uniqueStarts = [...new Set(wordStarts)];

  // Sort starts top-left to bottom-right
  uniqueStarts.sort((a, b) => {
    const [ar, ac] = a.split(',').map(Number);
    const [br, bc] = b.split(',').map(Number);
    return ar !== br ? ar - br : ac - bc;
  });

  // Assign clue numbers to all starts
  uniqueStarts.forEach(key => {
    cellNums[key] = num++;
  });

  const clues = { across: [], down: [] };

  placedWords.forEach(p => {
    const key = `${p.row},${p.col}`;
    const number = cellNums[key];
    const wordDef = wordDefs.find(w => w.word === p.word);
    clues[p.dir].push({
      number,
      clue: wordDef?.clue || `${p.word.length}-letter word`,
      answer: p.word,
      row: p.row,
      col: p.col,
      dir: p.dir,
    });
  });

  clues.across.sort((a,b) => a.number - b.number);
  clues.down.sort((a,b) => a.number - b.number);

  return { clues, cellNums };
}

// ===== PREVIEW RENDERING =====
function renderPreview(layout, clueData) {
  const panel = document.getElementById('rightPanel');
  const { grid, rows, cols, placedWords } = layout;
  const { clues, cellNums } = clueData;

  let html = `<div class="preview-label">${document.getElementById('puzzleTitle').value || 'Preview'} ‚Äî ${placedWords.length} words</div>`;
  
  html += `<div class="crossword-preview" style="grid-template-columns: repeat(${cols}, var(--cell-size)); grid-template-rows: repeat(${rows}, var(--cell-size)); display:inline-grid;">`;
  
  for (let r = 0; r < rows; r++) {
    for (let c = 0; c < cols; c++) {
      const raw = grid[r][c];
      const isBlack = (raw === '#' || raw === null);
      const num = cellNums[`${r},${c}`];
      html += `<div class="pcell ${isBlack ? 'black' : 'white'}">`;
      if (!isBlack) {
        if (num) html += `<div class="pcell-num">${num}</div>`;
        html += `<div class="pcell-letter">${raw || ''}</div>`;
      }
      html += '</div>';
    }
  }
  html += '</div>';

  // Clue list
  html += '<div class="preview-clues">';
  
  if (clues.across.length) {
    html += '<div class="pc-section"><h4>Across</h4>';
    clues.across.forEach(c => {
      html += `<div class="pc-clue"><span class="pc-num">${c.number}</span><span>${c.clue}</span></div>`;
    });
    html += '</div>';
  }

  if (clues.down.length) {
    html += '<div class="pc-section"><h4>Down</h4>';
    clues.down.forEach(c => {
      html += `<div class="pc-clue"><span class="pc-num">${c.number}</span><span>${c.clue}</span></div>`;
    });
    html += '</div>';
  }

  html += '</div>';
  panel.innerHTML = html;
}

// ===== SAVE / EXPORT =====
function buildPuzzleObject() {
  if (!currentGrid || !currentClues) {
    showStatus('Generate the grid preview first', 'error');
    return null;
  }

  const title = document.getElementById('puzzleTitle').value.trim() || 'Family Puzzle';
  const desc = document.getElementById('puzzleDesc').value.trim();

  return {
    title,
    description: desc,
    source: 'custom',
    gridData: currentGrid.grid,
    clues: currentClues.clues,
    answers: buildAnswerMap(currentClues.clues),
    wordCount: currentGrid.placedWords.length,
    created: Date.now(),
  };
}

function buildAnswerMap(clues) {
  const answers = {};
  clues.across?.forEach(c => { answers[`across_${c.number}`] = c.answer; });
  clues.down?.forEach(c => { answers[`down_${c.number}`] = c.answer; });
  return answers;
}

async function savePuzzle() {
  const puzzle = buildPuzzleObject();
  if (!puzzle) return;

  const btn = document.getElementById('saveBtn');
  btn.disabled = true;
  btn.textContent = 'Saving...';

  try {
    const ref = db.ref('custom_puzzles').push();
    await ref.set(puzzle);
    showStatus(`"${puzzle.title}" saved to cloud! ‚úì`, 'success');
    btn.textContent = '‚úì Saved!';
    setTimeout(() => { btn.textContent = 'Save to Cloud ‚òÅ'; btn.disabled = false; }, 3000);
  } catch(e) {
    showStatus('Save failed ‚Äî check Firebase config', 'error');
    btn.textContent = 'Save to Cloud ‚òÅ';
    btn.disabled = false;
  }
}

function exportPuzzle() {
  const puzzle = buildPuzzleObject();
  if (!puzzle) return;

  const blob = new Blob([JSON.stringify(puzzle, null, 2)], { type: 'application/json' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = `${puzzle.title.replace(/\s+/g,'-').toLowerCase()}.json`;
  a.click();
  URL.revokeObjectURL(url);
  showStatus('Puzzle exported!', 'success');
}

function showStatus(msg, type) {
  const bar = document.getElementById('statusBar');
  bar.textContent = msg;
  bar.className = `status-bar ${type}`;
  setTimeout(() => { bar.className = 'status-bar hidden'; }, 4000);
}

// Initialize word list
renderWordList();
</script>
</body>
</html>
